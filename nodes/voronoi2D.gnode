docformatrevision(19)
oid[1]=create("ShaderNodeSL","","Voronoi2D")
	oid[2]=create("ShaderNodeIn","$1","Input1")
		set("$2.Desc",types.enum {"st","Coords"})
		set("$2.HideInput",true)
		set("$2.PlugName","Input")
		set("$2.Value","st")
	oid[3]=create("ShaderNodeIn","$1","Input2")
		set("$3.Desc",LUIPSTypeVector)
		set("$3.HideInput",false)
		set("$3.PlugName","Coords")
		set("$3.Value",0)
	oid[4]=create("ShaderNodeIn","$1","Input3")
		set("$4.Desc",LUIPSTypeVector)
		set("$4.HideInput",false)
		set("$4.PlugName","Scale")
		set("$4.Value",{5,5,5})
	oid[5]=create("ShaderNodeIn","$1","Input4")
		set("$5.Desc",types.float {min=0,slidermax=1})
		set("$5.HideInput",false)
		set("$5.PlugName","Jitter")
		set("$5.Value",1)
	oid[6]=create("ShaderNodeOut","$1","Output1")
		set("$6.PlugName","CellCoords")
	oid[7]=create("ShaderNodeOut","$1","Output2")
		set("$7.PlugName","CellPosition")
	oid[8]=create("ShaderNodeOut","$1","Output3")
		set("$8.PlugName","CellIndex")
	set("$1.NodePos",{72.015306122446,-81.644897959186})
	set("$1.Script","// %param Input={type=types.enum{\"st\", \"Coords\"}, help=\"Input coordinates to use\"}\010// %param Coords={help=\"Input coordinates used if Input is set to 'Coords'\"}\010// %param Scale={help=\"Scale of coordinates\"}\010// %param Jitter={type=types.float{min=0,slidermax=1}, help=\"Amount of jitter for the cell position\"}\010\010\010float correctedCellNoise(point Position)\010{\010\009return clamp((cellnoise(Position) + 0.1) / 1.4, 0, 1);\010}\010\010// From Inigo Quizel article: http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\010void Voronoi2D(\009string Input = \"st\";\010\009\009\009\009vector Coords;\010\009\009\009\009vector Scale = vector(1,1,0);\009\010\009\009\009\009float Jitter = 1.0;\010\009\009\009\009output vector CellCoords;\010\009\009\009\009output point CellPosition;\010\009\009\009\009output vector CellIndex)\010{\010\009// Get the desired input coordinates\010\009Coords = Input == \"st\" ? st : Coords;\010\010\009// Scale position\010\009Coords = Coords * Scale;\010\010\009\009// Compute the cell center\010\009vector cellCenter = vector(\009floor(xcomp(Coords)),\010\009\009\009\009\009\009\009\009floor(ycomp(Coords)), 0);\010\009vector fract = vector(\009xcomp(Coords) - xcomp(cellCenter),\010\009\009\009\009\009\009\009ycomp(Coords) - ycomp(cellCenter), 0);\010\010\009float dist = 8; // = (2 * sqrt(2))^2 cubic diagonal which is the maximum distance between 2 cells\010\009vector pos = 0;\010\009vector cellPos = 0;\010\010\009// Loop over the neighboor cells\010\009float i, j;\010\010\009for (i=-1; i<=1; i+=1){\010\009\009for (j=-1; j<=1; j+=1)\010\009\009{\010\009\009\009// Compute jittered position of the neighboor cell\010\009\009\009vector nCell = vector(i, j, 0);\010\009\009\009vector cell = cellCenter + nCell;\010\009\009\009vector jPos = Jitter * (correctedCellNoise(cell));\010\009\009\009vector jCell = nCell + jPos - fract;\010\009\009\009\010\009\009\009// Compute the distance to the Position\010\009\009\009float d = jCell . jCell; // use dist^2\010\009\009\009cellPos = d < dist ? jPos + cell: cellPos;\010\009\009\009pos = d < dist ? jCell : pos;\010\009\009\009CellIndex = d < dist ? cell : CellIndex;\010\009\009\009dist = d < dist ? d : dist;\010\009\009}\010\009}\010\009\010\009CellCoords = vector(xcomp(pos), ycomp(pos), 0);\010\009CellPosition = point(cellPos + 0.5) / Scale;\010}")
