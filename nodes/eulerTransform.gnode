docformatrevision(19)
oid[1]=create("ShaderNodeSL","","EulerTransform")
	oid[2]=create("ShaderNodeIn","$1","Input1")
		set("$2.Desc",types.enum {"Left Handed (Guerilla)","Right Handed (Maya)"})
		set("$2.HideInput",true)
		set("$2.PlugName","CoordinatesMode")
		set("$2.Value","Left Handed (Guerilla)")
	oid[3]=create("ShaderNodeIn","$1","Input2")
		set("$3.Desc",types.enum {"Degrees","Radians"})
		set("$3.HideInput",true)
		set("$3.PlugName","AngleUnit")
		set("$3.Value","Degrees")
	oid[4]=create("ShaderNodeIn","$1","Input3")
		set("$4.Desc",types.point)
		set("$4.HideInput",false)
		set("$4.PlugName","Position")
		oid[5]=create("Plug","$4","DefaultInput",4,types.string,"(transform \"current\" \"world\" P)")
	oid[6]=create("ShaderNodeIn","$1","Input4")
		set("$6.Desc",types.vector)
		set("$6.HideInput",false)
		set("$6.PlugName","Translate")
		set("$6.Value",{0,0,0})
	oid[7]=create("ShaderNodeIn","$1","Input5")
		set("$7.Desc",types.vector)
		set("$7.HideInput",false)
		set("$7.PlugName","Rotate")
		set("$7.Value",0)
	oid[8]=create("ShaderNodeIn","$1","Input6")
		set("$8.Desc",types.vector)
		set("$8.HideInput",false)
		set("$8.PlugName","Scale")
		set("$8.Value",{1,1,1})
	oid[9]=create("ShaderNodeOut","$1","Output1")
		set("$9.PlugName","Output")
	set("$1.NodePos",{4.5,-1.5543122344752e-15})
	set("$1.Script","\010\010void matrixMult(vector m11, m12, m13, m21, m22, m23; output vector o1, o2, o3)\010{\010\009//Multiply matrices given in rows\010\010\009// Build column vector for second matrix\010\009vector mc21 = vector(m21[0], m22[0], m23[0]);\010\009vector mc22 = vector(m21[1], m22[1], m23[1]);\010\009vector mc23 = vector(m21[2], m22[2], m23[2]);\010\010\009// Multiply martices\010\009o1 = vector(m11.mc21, m11.mc22, m11.mc23);\010\009o2 = vector(m12.mc21, m12.mc22, m12.mc23);\010\009o3 = vector(m13.mc21, m13.mc22, m13.mc23);\010}\010\010vector matrixVecMult(vector m11, m12, m13, vec)\010{\010\009return vector(m11.vec, m12.vec, m13.vec);\010}\010\010// %param CoordinatesMode={name=\"Coordinates Mode\", type=types.enum {\"Left Handed (Guerilla)\", \"Right Handed (Maya)\"}, help=\"Type of coordinates system use.Z axis will be flipped in Right Handed mode.\"}\010// %param AngleUnit={name=\"Angle Unit\", type=types.enum {\"Degrees\", \"Radians\"}}\010// %param Position={type=types.point, help=\"Input position\"}\010// %param Translate={type=types.vector, help=\"Translation component\"}\010// %param Rotate={type=types.vector, help=\"Rotation component\"}\010// %param Scale={type=types.vector, help=\"Scale component\"}\010point getMatrix (string CoordinatesMode; string AngleUnit; point Position=transform(\"current\", \"world\", P); vector Translate, Rotate, Scale=vector(1))\010{\010\009Translate = CoordinatesMode == \"Right Handed\" ? vector(Translate[0], Translate[1], -Translate[2]) : Translate;\010\009Rotate = AngleUnit == \"Degrees\" ? Rotate*57.295779513 : Rotate;\010\009\010\009float cx = cos(Rotate[0]);\010\009float sx = sin(Rotate[0]);\010\009float cy = cos(Rotate[1]);\010\009float sy = sin(Rotate[1]);\010\009float cz = cos(Rotate[2]);\010\009float sz = sin(Rotate[2]);\010\010\009// Compute matrices as vectors (no support for matrix multiplication or indexing)\010\009vector mrx0 = vector(1, 0, 0);\010\009vector mrx1 = vector(0, cx, -sx);\010\009vector mrx2 = vector(0, sx, cx);\010\010\009vector mry0 = vector(cy, 0, sy);\010\009vector mry1 = vector(0, 1, 0);\010\009vector mry2 = vector(-sy, 0, cy);\010\010\009vector mrz0 = vector(cz, -sz, 0);\010\009vector mrz1 = vector(sz, cz, 0);\010\009vector mrz2 = vector(0, 0, 1);\010\010\009vector o1=vector(0), o2=vector(0), o3=vector(0);\010\010\009matrixMult(mrx0, mrx1, mrx2, mry0, mry1, mry2, o1, o2, o3);\010\009matrixMult(o1, o2, o3, mrz0, mrz1, mrz2, o1, o2, o3);\010\010\009o1 = o1 / Scale[0];\010\009o2 = o2 / Scale[1];\010\009o3 = o3 / Scale[2];\010\010\009return point(matrixVecMult(o1, o2, o3, Position - Translate));\010}\010")
