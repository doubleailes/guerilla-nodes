docformatrevision(19)
oid[1]=create("ShaderNodeSL","","eulerTransform")
	oid[2]=create("ShaderNodeIn","$1","Input1")
		set("$2.Desc",types.enum {"Left Handed (Guerilla)","Right Handed (Maya)"})
		set("$2.HideInput",true)
		set("$2.PlugName","CoordinatesMode")
		set("$2.Value","Left Handed (Guerilla)")
	oid[3]=create("ShaderNodeIn","$1","Input2")
		set("$3.Desc",types.enum {"Degrees","Radians"})
		set("$3.HideInput",true)
		set("$3.PlugName","AngleUnit")
		set("$3.Value","Radians")
	oid[4]=create("ShaderNodeIn","$1","Input3")
		set("$4.Desc",types.point)
		set("$4.HideInput",false)
		set("$4.PlugName","Position")
		oid[5]=create("Plug","$4","DefaultInput",4,types.string,"(transform \"current\" \"world\" P)")
	oid[6]=create("ShaderNodeIn","$1","Input4")
		set("$6.Desc",types.vector)
		set("$6.HideInput",false)
		set("$6.PlugName","Translate")
		set("$6.Value",0)
	oid[7]=create("ShaderNodeIn","$1","Input5")
		set("$7.Desc",types.vector)
		set("$7.HideInput",false)
		set("$7.PlugName","Rotate")
		set("$7.Value",{0,0,0})
	oid[8]=create("ShaderNodeIn","$1","Input6")
		set("$8.Desc",types.vector)
		set("$8.HideInput",false)
		set("$8.PlugName","Scale")
		set("$8.Value",{1,1,1})
	oid[9]=create("ShaderNodeOut","$1","Output1")
		set("$9.PlugName","Output")
	set("$1.Code","func matrixMult m11 m12 m13 m21 m22 m23 &o1 &o2 &o3\010{\010\009= o1 0\010\009= o2 0\010\009= o3 0\010\009decl mc21\010\009= mc21 (vector3 (comp m21 0) (comp m22 0) (comp m23 0))\010\009decl mc22\010\009= mc22 (vector3 (comp m21 1) (comp m22 1) (comp m23 1))\010\009decl mc23\010\009= mc23 (vector3 (comp m21 2) (comp m22 2) (comp m23 2))\010\009= o1 (vector3 (dot m11 mc21) (dot m11 mc22) (dot m11 mc23))\010\009= o2 (vector3 (dot m12 mc21) (dot m12 mc22) (dot m12 mc23))\010\009= o3 (vector3 (dot m13 mc21) (dot m13 mc22) (dot m13 mc23))\010}\010func matrixVecMult m11 m12 m13 vec\010{\010\009decl i_result\010\009= i_result (vector3 (dot m11 vec) (dot m12 vec) (dot m13 vec))\010\009return i_result\010}\010func getMatrix CoordinatesMode AngleUnit Position Translate Rotate Scale\010{\010\009decl i_result\010\009= Translate (select (cmpeq CoordinatesMode \"Right Handed (Maya)\") (vector3 (comp Translate 0) (comp Translate 1) (neg (comp Translate 2))) Translate)\010\009= Rotate (select (cmpeq AngleUnit \"Degrees\") (mul Rotate 0.0174533) Rotate)\010\009= Rotate (select (cmpeq CoordinatesMode \"Right Handed (Maya)\") (vector3 (comp Rotate 0) (comp Rotate 1) (neg (comp Rotate 2))) Rotate)\010\009decl cx\010\009= cx (cos (comp Rotate 0))\010\009decl sx\010\009= sx (sin (comp Rotate 0))\010\009decl cy\010\009= cy (cos (comp Rotate 1))\010\009decl sy\010\009= sy (sin (comp Rotate 1))\010\009decl cz\010\009= cz (cos (comp Rotate 2))\010\009decl sz\010\009= sz (sin (comp Rotate 2))\010\009decl mrx0\010\009= mrx0 (vector3 1 0 0)\010\009decl mrx1\010\009= mrx1 (vector3 0 cx (neg sx))\010\009decl mrx2\010\009= mrx2 (vector3 0 sx cx)\010\009decl mry0\010\009= mry0 (vector3 cy 0 sy)\010\009decl mry1\010\009= mry1 (vector3 0 1 0)\010\009decl mry2\010\009= mry2 (vector3 (neg sy) 0 cy)\010\009decl mrz0\010\009= mrz0 (vector3 cz (neg sz) 0)\010\009decl mrz1\010\009= mrz1 (vector3 sz cz 0)\010\009decl mrz2\010\009= mrz2 (vector3 0 0 1)\010\009decl o1\010\009= o1 { decl __casttmp = __casttmp 0 return (vector3 __casttmp __casttmp __casttmp) }\010\009decl o2\010\009= o2 { decl __casttmp = __casttmp 0 return (vector3 __casttmp __casttmp __casttmp) }\010\009decl o3\010\009= o3 { decl __casttmp = __casttmp 0 return (vector3 __casttmp __casttmp __casttmp) }\010\009(matrixMult mrx0 mrx1 mrx2 mry0 mry1 mry2 o1 o2 o3)\010\009(matrixMult o1 o2 o3 mrz0 mrz1 mrz2 o1 o2 o3)\010\009= o1 (div o1 (comp Scale 0))\010\009= o2 (div o2 (comp Scale 1))\010\009= o3 (div o3 (comp Scale 2))\010\009= o3 (select (cmpeq CoordinatesMode \"Right Handed (Maya)\") (neg o3) o3)\010\009= i_result (matrixVecMult o1 o2 o3 (sub Position Translate))\010\009return i_result\010}\010= out1 (getMatrix arg1 arg2 arg3 arg4 arg5 arg6)")
	set("$1.NodePos",{-160.07809860116,194.60647511085})
	set("$1.Script","\013\010\013\010void matrixMult(vector m11, m12, m13, m21, m22, m23; output vector o1, o2, o3)\013\010{\013\010\009//Multiply matrices given in rows\013\010\013\010\009// Build column vector for second matrix\013\010\009vector mc21 = vector(m21[0], m22[0], m23[0]);\013\010\009vector mc22 = vector(m21[1], m22[1], m23[1]);\013\010\009vector mc23 = vector(m21[2], m22[2], m23[2]);\013\010\013\010\009// Multiply martices\013\010\009o1 = vector(m11.mc21, m11.mc22, m11.mc23);\013\010\009o2 = vector(m12.mc21, m12.mc22, m12.mc23);\013\010\009o3 = vector(m13.mc21, m13.mc22, m13.mc23);\013\010}\013\010\013\010vector matrixVecMult(vector m11, m12, m13, vec)\013\010{\013\010\009return vector(m11.vec, m12.vec, m13.vec);\013\010}\013\010\013\010// %param CoordinatesMode={name=\"Coordinates Mode\", type=types.enum {\"Left Handed (Guerilla)\", \"Right Handed (Maya)\"}, help=\"Type of coordinates system use.Z axis will be flipped in Right Handed mode.\"}\013\010// %param AngleUnit={name=\"Angle Unit\", type=types.enum {\"Degrees\", \"Radians\"}}\013\010// %param Position={type=types.point, help=\"Input position\"}\013\010// %param Translate={type=types.vector, help=\"Translation component\"}\013\010// %param Rotate={type=types.vector, help=\"Rotation component\"}\013\010// %param Scale={type=types.vector, help=\"Scale component\"}\013\010point getMatrix (string CoordinatesMode; string AngleUnit; point Position=transform(\"current\", \"world\", P); vector Translate, Rotate, Scale=vector(1))\013\010{\013\010\009Translate = CoordinatesMode == \"Right Handed (Maya)\" ? vector(Translate[0], Translate[1], -Translate[2]) : Translate;\013\010\009Rotate = AngleUnit == \"Degrees\" ? Rotate*0.01745329252 : Rotate;\013\010\009Rotate = CoordinatesMode == \"Right Handed (Maya)\" ? vector(Rotate[0], Rotate[1], -Rotate[2]) : Rotate;\013\010\009\013\010\009float cx = cos(Rotate[0]);\013\010\009float sx = sin(Rotate[0]);\013\010\009float cy = cos(Rotate[1]);\013\010\009float sy = sin(Rotate[1]);\013\010\009float cz = cos(Rotate[2]);\013\010\009float sz = sin(Rotate[2]);\013\010\013\010\009// Compute matrices as vectors (no support for matrix multiplication or indexing)\013\010\009vector mrx0 = vector(1, 0, 0);\013\010\009vector mrx1 = vector(0, cx, -sx);\013\010\009vector mrx2 = vector(0, sx, cx);\013\010\013\010\009vector mry0 = vector(cy, 0, sy);\013\010\009vector mry1 = vector(0, 1, 0);\013\010\009vector mry2 = vector(-sy, 0, cy);\013\010\013\010\009vector mrz0 = vector(cz, -sz, 0);\013\010\009vector mrz1 = vector(sz, cz, 0);\013\010\009vector mrz2 = vector(0, 0, 1);\013\010\013\010\009vector o1=vector(0), o2=vector(0), o3=vector(0);\013\010\013\010\009matrixMult(mrx0, mrx1, mrx2, mry0, mry1, mry2, o1, o2, o3);\013\010\009matrixMult(o1, o2, o3, mrz0, mrz1, mrz2, o1, o2, o3);\013\010\013\010\009o1 = o1 / Scale[0];\013\010\009o2 = o2 / Scale[1];\013\010\009o3 = o3 / Scale[2];\013\010\013\010\009o3 = CoordinatesMode == \"Right Handed (Maya)\" ? -o3 : o3;\013\010\013\010\009return point(matrixVecMult(o1, o2, o3, Position - Translate));\013\010}\013\010")
